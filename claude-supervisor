#!/usr/bin/env node

/**
 * Claude Code Supervisor
 *
 * A hook script that validates tool use and permission requests using
 * fast-path rules and Codex LLM for intelligent decisions.
 *
 * Usage: claude-supervisor <pre-tool-use|permission-request|post-tool-use>
 * Input: JSON from stdin (Claude Code hook format)
 * Output: JSON decision to stdout
 *
 * Environment Variables:
 *   CLAUDE_SUPERVISOR_DEBUG=1        - Enable debug output to stderr
 *   CLAUDE_SUPERVISOR_AUTO_ACCEPT=1  - Auto-accept all actions (bypass supervisor)
 *   CLAUDE_SUPERVISOR_AUTO_ACCEPT=learned - Only auto-accept learned patterns
 */

const { spawnSync } = require('child_process');
const { readFileSync, writeFileSync, realpathSync, existsSync, mkdirSync, appendFileSync } = require('fs');
const { homedir } = require('os');
const path = require('path');

// Configuration
const CODEX_TIMEOUT_MS = 15000; // 15 seconds for Codex to respond
const DEBUG = process.env.CLAUDE_SUPERVISOR_DEBUG === '1';
const LOG_DIR = path.join(homedir(), 'Library', 'Logs', 'claude-supervisor');
const SESSION_STATE_DIR = '/tmp/claude-supervisor-sessions';

// Auto-accept modes via environment variable
// Values: '1' or 'all' = accept everything, 'learned' = only learned patterns
const AUTO_ACCEPT = process.env.CLAUDE_SUPERVISOR_AUTO_ACCEPT || '';

// Disable supervisor completely - returns nothing so Claude uses default behavior
const DISABLED = process.env.CLAUDE_SUPERVISOR_DISABLED === '1';

// Ensure directories exist
try { mkdirSync(SESSION_STATE_DIR, { recursive: true }); } catch {}
try { mkdirSync(LOG_DIR, { recursive: true }); } catch {}

// ============================================================================
// Logging Functions
// ============================================================================

function getTimestamp() {
  return new Date().toISOString();
}

function getLogFilePath() {
  const date = new Date().toISOString().split('T')[0];
  return path.join(LOG_DIR, `supervisor-${date}.log`);
}

function log(level, message, data = null) {
  try {
    const logEntry = { timestamp: getTimestamp(), level, message, ...(data && { data }) };
    appendFileSync(getLogFilePath(), JSON.stringify(logEntry) + '\n');
  } catch {}
}

function debug(...args) {
  if (DEBUG) console.error('[supervisor]', ...args);
}

function logRequest(hookType, input) {
  log('INFO', 'Request received', {
    hookType,
    sessionId: input?.session_id,
    toolName: input?.tool_name,
    cwd: input?.cwd,
    toolInput: input?.tool_input
  });
}

function logDecision(decision, reason, source, input) {
  log('INFO', 'Decision made', {
    decision, reason, source,
    toolName: input?.tool_name,
    sessionId: input?.session_id
  });
}

function logError(message, error, context = null) {
  log('ERROR', message, {
    error: error?.message || String(error),
    stack: error?.stack,
    ...(context && { context })
  });
}

// ============================================================================
// Session State Management - Learn from user decisions during a session
// ============================================================================

function getSessionStateFilePath(sessionId) {
  if (!sessionId) return null;
  const safeId = sessionId.replace(/[^a-zA-Z0-9-_]/g, '_');
  return path.join(SESSION_STATE_DIR, `${safeId}.json`);
}

function loadSessionState(sessionId) {
  const filePath = getSessionStateFilePath(sessionId);
  if (!filePath) return { allowedPatterns: [], deniedPatterns: [], toolsAllowed: [], userPrompts: [] };
  try {
    if (existsSync(filePath)) {
      const state = JSON.parse(readFileSync(filePath, 'utf8'));
      // Ensure userPrompts array exists for older session files
      if (!state.userPrompts) state.userPrompts = [];
      return state;
    }
  } catch (err) {
    debug('Failed to load session state:', err.message);
  }
  return { allowedPatterns: [], deniedPatterns: [], toolsAllowed: [], userPrompts: [] };
}

/**
 * Store user prompt in session state for context
 * Keeps only the last few prompts to avoid unbounded growth
 */
function recordUserPrompt(sessionId, prompt) {
  if (!sessionId || !prompt) return;

  const state = loadSessionState(sessionId);
  const MAX_PROMPTS = 5; // Keep last 5 prompts for context

  state.userPrompts.push({
    timestamp: getTimestamp(),
    prompt: prompt.substring(0, 500) // Truncate long prompts
  });

  // Keep only the last N prompts
  if (state.userPrompts.length > MAX_PROMPTS) {
    state.userPrompts = state.userPrompts.slice(-MAX_PROMPTS);
  }

  saveSessionState(sessionId, state);
  debug('Recorded user prompt:', prompt.substring(0, 100));
}

/**
 * Get recent user prompts for context
 */
function getRecentPrompts(sessionId) {
  const state = loadSessionState(sessionId);
  return state.userPrompts || [];
}

function saveSessionState(sessionId, state) {
  const filePath = getSessionStateFilePath(sessionId);
  if (!filePath) return;
  try {
    writeFileSync(filePath, JSON.stringify(state, null, 2));
  } catch (err) {
    debug('Failed to save session state:', err.message);
  }
}

/**
 * Commands that modify files and need scope-awareness
 */
const FILE_MODIFYING_COMMANDS = [
  'rm', 'mv', 'cp', 'chmod', 'chown', 'touch', 'mkdir', 'rmdir',
  'ln', 'install', 'rsync', 'tar', 'unzip', 'zip', 'gzip', 'gunzip'
];

/**
 * Commands that are safe to learn globally (don't modify arbitrary files)
 */
const SAFE_GLOBAL_COMMANDS = [
  'cd', 'ls', 'pwd', 'echo', 'cat', 'head', 'tail', 'wc', 'date', 'whoami',
  'hostname', 'uname', 'env', 'which', 'type', 'file', 'stat', 'find',
  'grep', 'rg', 'ag', 'awk', 'sed', 'sort', 'uniq', 'cut', 'tr', 'jq',
  'git', 'npm', 'npx', 'pnpm', 'yarn', 'node', 'python', 'python3',
  'pip', 'pip3', 'cargo', 'go', 'make', 'docker', 'docker-compose',
  'kubectl', 'helm', 'brew', 'apt', 'yum', 'code', 'vim', 'nano', 'open'
];

/**
 * Network/remote commands that need host-specific pattern learning (not blanket approval)
 */
const NETWORK_COMMANDS = ['curl', 'wget', 'http', 'httpie', 'ssh', 'scp', 'rsync', 'sftp'];

/**
 * Extract URL from a curl/wget command
 */
function extractUrlFromNetworkCommand(command) {
  // Match URLs in the command (quoted or unquoted)
  const urlMatch = command.match(/https?:\/\/[^\s"']+|"https?:\/\/[^"]+"|'https?:\/\/[^']+'/);
  if (urlMatch) {
    return urlMatch[0].replace(/^["']|["']$/g, ''); // Remove quotes
  }
  return null;
}

/**
 * Extract hostname and remote command from ssh/scp/rsync command
 * Returns { host, remoteCmd } or null
 */
function extractRemoteCommandInfo(command) {
  // ssh user@host 'command' or ssh user@host "command"
  const sshMatch = command.match(/(?:ssh|sftp)\s+(?:-[^\s]+\s+)*(?:\w+@)?([a-zA-Z0-9._-]+)\s+['"](.+)['"]/);
  if (sshMatch) {
    const remoteCmd = sshMatch[2].trim().split(/\s+/)[0]; // First word of remote command
    return { host: sshMatch[1], remoteCmd };
  }

  // ssh user@host command (without quotes)
  const sshUnquotedMatch = command.match(/(?:ssh|sftp)\s+(?:-[^\s]+\s+)*(?:\w+@)?([a-zA-Z0-9._-]+)\s+(\S+)/);
  if (sshUnquotedMatch) {
    return { host: sshUnquotedMatch[1], remoteCmd: sshUnquotedMatch[2] };
  }

  // ssh user@host (just connection, no command)
  const sshConnectMatch = command.match(/(?:ssh|sftp)\s+(?:-[^\s]+\s+)*(?:\w+@)?([a-zA-Z0-9._-]+)\s*$/);
  if (sshConnectMatch) {
    return { host: sshConnectMatch[1], remoteCmd: 'shell' };
  }

  // scp/rsync - extract host and use 'transfer' as command type
  const scpMatch = command.match(/(?:scp|rsync)\s+.*?(?:\w+@)?([a-zA-Z0-9._-]+):/);
  if (scpMatch) {
    return { host: scpMatch[1], remoteCmd: 'transfer' };
  }

  return null;
}


/**
 * Extract potential file paths from a bash command
 */
function extractPathsFromCommand(command) {
  const paths = [];
  // Match quoted strings and unquoted paths
  const tokens = command.match(/"[^"]*"|'[^']*'|[^\s]+/g) || [];

  for (const token of tokens) {
    // Remove quotes
    const cleaned = token.replace(/^["']|["']$/g, '');
    // Check if it looks like a path (starts with /, ~, or ./)
    if (/^[\/~.]/.test(cleaned) || cleaned.includes('/')) {
      paths.push(cleaned);
    }
  }
  return paths;
}

/**
 * Check if all paths in a command are within the project directory or worktrees
 */
function commandIsWithinProject(command, projectDir) {
  const paths = extractPathsFromCommand(command);
  if (paths.length === 0) return true; // No paths = assume project-scoped

  for (const p of paths) {
    const expanded = expandPath(p);
    if (!isWithinProjectOrWorktree(expanded, projectDir)) {
      return false;
    }
  }
  return true;
}

/**
 * Generate pattern keys for matching similar actions
 */
function generatePatternKeys(input) {
  const { tool_name, tool_input, cwd } = input;
  const projectDir = process.env.CLAUDE_PROJECT_DIR || cwd;
  const patterns = [];

  if (tool_name === 'Bash') {
    const cmd = tool_input?.command || '';
    const cmdParts = cmd.trim().split(/\s+/);
    if (cmdParts.length === 0) return patterns;

    const baseCmd = cmdParts[0];
    const firstArg = cmdParts.length > 1 ? cmdParts[1] : null;

    // Network/remote commands need host-specific patterns
    if (NETWORK_COMMANDS.includes(baseCmd)) {
      // Try URL extraction for curl/wget
      const url = extractUrlFromNetworkCommand(cmd);
      if (url) {
        try {
          const urlObj = new URL(url);
          patterns.push(`Bash:${baseCmd}:host:${urlObj.hostname}`);
        } catch {
          // Invalid URL - try host extraction
        }
      }
      // Try host+command extraction for ssh/scp/rsync
      const remoteInfo = extractRemoteCommandInfo(cmd);
      if (remoteInfo) {
        // Include the remote command in the pattern: ssh:host:sendnix.de:cat
        patterns.push(`Bash:${baseCmd}:host:${remoteInfo.host}:${remoteInfo.remoteCmd}`);
      }
      // Don't add broad Bash:ssh or Bash:curl pattern - require host-specific approval
    } else if (FILE_MODIFYING_COMMANDS.includes(baseCmd)) {
      // For file-modifying commands, only learn if within project
      if (commandIsWithinProject(cmd, projectDir)) {
        patterns.push(`Bash:${baseCmd}:in-project`);
        if (firstArg && firstArg.startsWith('-')) {
          patterns.push(`Bash:${baseCmd}:${firstArg}:in-project`);
        }
      }
      // Don't learn global patterns for file-modifying commands outside project
    } else if (SAFE_GLOBAL_COMMANDS.includes(baseCmd)) {
      // Safe commands can be learned globally
      patterns.push(`Bash:${baseCmd}`);
      if (firstArg) {
        patterns.push(`Bash:${baseCmd}:${firstArg}`);
      }
    } else {
      // Unknown commands - be conservative, scope to project
      if (commandIsWithinProject(cmd, projectDir)) {
        patterns.push(`Bash:${baseCmd}:in-project`);
      }
      // Also learn the specific command pattern (less broad)
      patterns.push(`Bash:${baseCmd}`);
    }
  } else if (FILE_MODIFY_TOOLS.includes(tool_name) || ALWAYS_SAFE_TOOLS.includes(tool_name)) {
    const filePath = getFilePath(tool_input);
    if (filePath) {
      const dir = path.dirname(filePath);
      patterns.push(`${tool_name}:dir:${dir}`);
      const ext = path.extname(filePath);
      if (ext) patterns.push(`${tool_name}:ext:${ext}`);
    }
  } else if (tool_name === 'WebFetch' || tool_name === 'WebSearch') {
    const url = tool_input?.url || tool_input?.query || '';
    try {
      const urlObj = new URL(url);
      patterns.push(`${tool_name}:domain:${urlObj.hostname}`);
    } catch {
      patterns.push(`${tool_name}:${url.substring(0, 30)}`);
    }
  }

  // Don't add Tool:Bash for file-modifying or network commands (too broad)
  if (tool_name === 'Bash') {
    const baseCmd = (tool_input?.command || '').trim().split(/\s+/)[0];
    if (!FILE_MODIFYING_COMMANDS.includes(baseCmd) && !NETWORK_COMMANDS.includes(baseCmd)) {
      patterns.push(`Tool:${tool_name}`);
    }
  } else {
    patterns.push(`Tool:${tool_name}`);
  }

  return patterns;
}

function checkSessionAllowed(sessionId, input) {
  const state = loadSessionState(sessionId);
  const patterns = generatePatternKeys(input);

  debug('Checking session patterns:', patterns);
  debug('Allowed patterns:', state.allowedPatterns);

  for (const pattern of patterns) {
    if (state.allowedPatterns.includes(pattern)) {
      return { allowed: true, pattern };
    }
  }

  if (state.toolsAllowed.includes(input.tool_name)) {
    return { allowed: true, pattern: `Tool:${input.tool_name}` };
  }

  return { allowed: false };
}

function recordAllowedAction(sessionId, input) {
  if (!sessionId) return { added: [], existing: [] };

  const state = loadSessionState(sessionId);
  const patterns = generatePatternKeys(input);
  const added = [];
  const existing = [];

  for (const pattern of patterns) {
    if (!state.allowedPatterns.includes(pattern)) {
      state.allowedPatterns.push(pattern);
      added.push(pattern);
    } else {
      existing.push(pattern);
    }
  }

  if (added.length > 0) {
    state.lastUpdated = getTimestamp();
    saveSessionState(sessionId, state);
    log('INFO', 'Recorded allowed action in session', { sessionId, added, existing });
  }

  return { added, existing };
}

function isAutoAcceptEnabled() {
  const mode = AUTO_ACCEPT.toLowerCase();
  return mode === '1' || mode === 'all' || mode === 'true';
}

function isLearnedAutoAcceptEnabled() {
  return AUTO_ACCEPT.toLowerCase() === 'learned';
}

// ============================================================================
// Security Rules
// ============================================================================

// HARD BLOCK: These are truly dangerous - no exceptions
const ALWAYS_DENY_PATHS = [
  /[/\\]\.ssh[/\\]/i,           // SSH keys - never allow
  /[/\\]\.gnupg[/\\]/i,         // GPG keys - never allow
];

// SOFT BLOCK: Ask user instead of denying - might be legitimate
const ASK_USER_PATHS = [
  /[/\\]\.aws[/\\]credentials/i,
  /[/\\]\.aws[/\\]config/i,
  /^\/etc\/(passwd|shadow|sudoers)/,
  /[/\\]\.password-store[/\\]/i,
  /[/\\]\.netrc$/i,
  /[/\\]\.npmrc$/i,
  /[/\\]\.pypirc$/i,
  /[/\\]\.bashrc$/i,
  /[/\\]\.zshrc$/i,
  /[/\\]\.profile$/i,
  /[/\\]\.bash_profile$/i,
  /[/\\]\.zprofile$/i,
  /[/\\]\.gitconfig$/i,
];

// HARD BLOCK: Truly dangerous bash patterns - no exceptions
const DANGEROUS_BASH_PATTERNS = [
  /curl\s+.*\|\s*(ba)?sh/i,              // Pipe curl to shell
  /wget\s+.*\|\s*(ba)?sh/i,              // Pipe wget to shell
  /curl\s+.*>\s*.*\.sh\s*&&\s*(ba)?sh/i, // Download and execute
  />\s*\/dev\/sd[a-z]/i,                 // Write to disk device
  /mkfs\./i,                             // Format filesystem
  /dd\s+.*of=\/dev\//i,                  // dd to device
  /:\(\)\s*\{\s*:\|:\s*&\s*\}/,          // Fork bomb
];

// SOFT BLOCK: Potentially dangerous but might be legitimate - ask user
const ASK_USER_BASH_PATTERNS = [
  /rm\s+(-rf?|--recursive)\s+[/~]/i,     // rm -rf - might be cleanup
  /chmod\s+777/i,                         // chmod 777 - might be intentional
  /sudo\s+/i,                             // sudo commands - ask first
  /(curl|wget|http)[\s\S]*(-H|--header)/i, // curl/wget with headers (often contain API keys)
  /(curl|wget|http)[\s\S]*(api.?key|token|secret|password|auth|bearer)/i, // curl with credentials
  /(curl|wget|http)[\s\S]*-X\s*(DELETE|PUT|POST|PATCH)/i, // curl with modifying HTTP methods
];

const ALWAYS_SAFE_TOOLS = ['Read', 'Glob', 'Grep', 'LSP', 'ListMcpResourcesTool', 'ReadMcpResourceTool'];
const FILE_MODIFY_TOOLS = ['Edit', 'Write', 'NotebookEdit'];

// ============================================================================
// Helper Functions
// ============================================================================

function expandPath(filePath) {
  if (!filePath) return null;
  if (filePath.startsWith('~')) return path.join(homedir(), filePath.slice(1));
  return filePath;
}

function normalizePath(filePath) {
  const expanded = expandPath(filePath);
  if (!expanded) return null;
  try {
    return existsSync(expanded) ? realpathSync(expanded) : path.resolve(expanded);
  } catch {
    return path.resolve(expanded);
  }
}

function isWithinDirectory(filePath, directory) {
  if (!filePath || !directory) return false;
  const normalizedFile = normalizePath(filePath);
  const normalizedDir = normalizePath(directory);
  if (!normalizedFile || !normalizedDir) return false;
  return normalizedFile.startsWith(normalizedDir + path.sep) || normalizedFile === normalizedDir;
}

/**
 * Get all git worktree directories for a project
 * @param {string} projectDir - The project directory
 * @returns {string[]} Array of worktree paths
 */
function getGitWorktrees(projectDir) {
  try {
    const result = spawnSync('git', ['worktree', 'list', '--porcelain'], {
      cwd: projectDir,
      encoding: 'utf8',
      timeout: 5000,
    });
    if (result.status !== 0) return [];

    const worktrees = [];
    const lines = result.stdout.split('\n');
    for (const line of lines) {
      if (line.startsWith('worktree ')) {
        worktrees.push(line.substring(9)); // Remove 'worktree ' prefix
      }
    }
    return worktrees;
  } catch {
    return [];
  }
}

// Cache worktrees per session to avoid repeated git calls
let cachedWorktrees = null;
let cachedProjectDir = null;

function getWorktreesForProject(projectDir) {
  if (cachedProjectDir === projectDir && cachedWorktrees !== null) {
    return cachedWorktrees;
  }
  cachedProjectDir = projectDir;
  cachedWorktrees = getGitWorktrees(projectDir);
  debug('Detected worktrees:', cachedWorktrees);
  return cachedWorktrees;
}

/**
 * Check if a path is within the project or any of its worktrees
 */
function isWithinProjectOrWorktree(filePath, projectDir) {
  if (isWithinDirectory(filePath, projectDir)) return true;

  const worktrees = getWorktreesForProject(projectDir);
  for (const worktree of worktrees) {
    if (isWithinDirectory(filePath, worktree)) return true;
  }
  return false;
}

function matchesAnyPattern(str, patterns) {
  if (!str) return false;
  return patterns.some(pattern => pattern.test(str));
}

function getFilePath(toolInput) {
  return toolInput?.file_path || toolInput?.filePath || toolInput?.path || toolInput?.notebook_path || null;
}

// ============================================================================
// Fast-Path Rules (No LLM needed)
// ============================================================================

function checkFastPathRules(input) {
  const { tool_name, tool_input, cwd } = input;
  const projectDir = process.env.CLAUDE_PROJECT_DIR || cwd;

  debug('Checking fast-path rules for:', tool_name);

  // 1. Always-safe read-only tools - allow anywhere except sensitive paths
  if (ALWAYS_SAFE_TOOLS.includes(tool_name)) {
    const filePath = getFilePath(tool_input);
    const expandedPath = filePath ? expandPath(filePath) : null;

    // Hard block: SSH/GPG keys
    if (expandedPath && matchesAnyPattern(expandedPath, ALWAYS_DENY_PATHS)) {
      return { decision: 'deny', reason: `Access to sensitive path blocked: ${filePath}` };
    }
    // Soft block: Other sensitive paths - ask user
    if (expandedPath && matchesAnyPattern(expandedPath, ASK_USER_PATHS)) {
      return { decision: 'ask', reason: `Reading sensitive file: ${filePath}` };
    }
    // Read-only tools are safe anywhere
    return { decision: 'allow', reason: 'Safe read-only operation', silent: true };
  }

  // 2. File modification tools
  if (FILE_MODIFY_TOOLS.includes(tool_name)) {
    const filePath = getFilePath(tool_input);
    if (!filePath) return null;

    const expandedPath = expandPath(filePath);

    // Always allow: Claude Code plan files
    if (isWithinDirectory(expandedPath, path.join(homedir(), '.claude', 'plans'))) {
      return { decision: 'allow', reason: 'Claude Code plan file', silent: true };
    }

    // Hard block: SSH/GPG keys - never allow modification
    if (matchesAnyPattern(expandedPath, ALWAYS_DENY_PATHS)) {
      return { decision: 'deny', reason: `Modification of sensitive path blocked: ${filePath}` };
    }
    // Soft block: Other sensitive paths - ask user
    if (matchesAnyPattern(expandedPath, ASK_USER_PATHS)) {
      return { decision: 'ask', reason: `Modifying sensitive file: ${filePath}` };
    }
    // Allow within project or worktrees
    if (isWithinProjectOrWorktree(filePath, projectDir)) {
      return { decision: 'allow', reason: 'File modification within project directory' };
    }
    // Outside project/worktrees - ask instead of blocking
    return { decision: 'ask', reason: `File outside project: ${filePath}` };
  }

  // 3. Bash commands
  if (tool_name === 'Bash') {
    const command = tool_input?.command || '';

    // Hard block: Truly dangerous patterns (phishing, device writes, fork bombs)
    if (matchesAnyPattern(command, DANGEROUS_BASH_PATTERNS)) {
      return { decision: 'deny', reason: `Dangerous bash pattern blocked: ${command.substring(0, 100)}` };
    }

    // Soft block: Potentially risky but might be legitimate - ask user
    if (matchesAnyPattern(command, ASK_USER_BASH_PATTERNS)) {
      return { decision: 'ask', reason: `Potentially risky command: ${command.substring(0, 80)}` };
    }

    // Allow only truly safe, read-only/info commands
    // Everything else goes to LLM for smarter context-aware decisions
    const safeCommands = [
      // Info-only commands that can't modify anything
      /^(ls|pwd|echo|cat|head|tail|wc|date|whoami|hostname|uname|env|which|type|file|stat|id|groups|printenv)\b/,
      // Read-only git commands (no fetch/pull/push/checkout/commit)
      /^git\s+(status|log|diff|show|branch|remote|stash\s+list|config\s+--get)\b/,
      // Package info only (no install/run/exec)
      /^(npm|pnpm|yarn)\s+(list|ls|outdated|info|view|why)\b/,
      /^pip\s+(list|show|freeze)\b/,
      // Container/cluster info only (no run/exec/apply/delete)
      /^docker\s+(ps|images|inspect|logs|version|info)\b/,
      /^(kubectl|helm)\s+(get|describe|logs|version)\b/,
      // Package manager info only (no install/update)
      /^(brew|apt|yum|dnf)\s+(list|info|search|show)\b/,
      // Text processing (read-only)
      /^(jq|grep|rg|ag|awk|sed|sort|uniq|cut|tr|tee|diff|comm|join)\b/,
      // Open apps/editors (user will see what opens)
      /^(code|open)\b/,
    ];
    if (safeCommands.some(pattern => pattern.test(command))) {
      return { decision: 'allow', reason: 'Safe read-only command' };
    }

    // Unknown command - let LLM decide or ask
    return null;
  }

  // 4. Web operations
  if (tool_name === 'WebFetch' || tool_name === 'WebSearch') {
    const url = tool_input?.url || '';
    if (/^https?:\/\/(localhost|127\.0\.0\.1|0\.0\.0\.0|192\.168\.|10\.|172\.(1[6-9]|2[0-9]|3[01])\.)/i.test(url)) {
      return null; // Let LLM decide for local URLs
    }
    return { decision: 'allow', reason: 'Web operation allowed' };
  }

  // 5. MCP tools
  if (tool_name.startsWith('mcp__')) {
    return { decision: 'allow', reason: 'MCP tool operation' };
  }

  // 6. Task/Agent tools (silent - not interesting to user)
  if (tool_name === 'Task' || tool_name === 'TodoWrite' || tool_name === 'AskUserQuestion') {
    return { decision: 'allow', reason: 'Internal Claude operation', silent: true };
  }

  return null;
}

// ============================================================================
// Codex LLM Integration
// ============================================================================

function buildCodexPrompt(input, sessionId) {
  const { tool_name, tool_input, cwd, hook_event_name } = input;

  // Get recent user prompts for context
  const recentPrompts = getRecentPrompts(sessionId);
  let userContext = '';
  if (recentPrompts.length > 0) {
    const promptTexts = recentPrompts.map(p => p.prompt).join('\n- ');
    userContext = `\nUSER CONTEXT (recent requests):\n- ${promptTexts}\n`;
  }

  return `You are a security advisor for Claude Code. Analyze this action and decide if it should be auto-approved or if the user should be asked.

EVENT: ${hook_event_name}
PROJECT DIRECTORY: ${cwd}
TOOL: ${tool_name}
INPUT: ${JSON.stringify(tool_input, null, 2)}
${userContext}
RULES:
- ALLOW actions that are clearly within the project scope
- ALLOW actions that align with what the user requested in their recent prompts
- ALLOW relevant documentation/resource fetches
- ALLOW standard development commands (build, test, lint, etc.)
- ASK for actions involving credentials, API keys, or sensitive files (let user decide)
- ASK for modifications to system files or shell configurations
- ASK for network requests with embedded secrets
- ASK when uncertain or the action seems unusual

For dangerous actions, include "⚠️ WARNING:" in the reason to alert the user.

Respond with ONLY a JSON object (no markdown, no explanation):
{"decision": "allow", "reason": "brief reason"}
or
{"decision": "ask", "reason": "brief concern, or ⚠️ WARNING: serious concern"}`;
}

function callCodex(prompt) {
  try {
    debug('Calling Codex...');
    const result = spawnSync('codex', ['exec', '-', '--json', '--skip-git-repo-check'], {
      input: prompt,
      encoding: 'utf8',
      timeout: CODEX_TIMEOUT_MS,
      maxBuffer: 1024 * 1024,
    });

    if (result.error) {
      debug('Codex error:', result.error);
      log('ERROR', 'Codex spawn error', { error: result.error.message });
      return null;
    }

    if (result.status !== 0) {
      debug('Codex non-zero exit:', result.status, result.stderr);
      log('WARN', 'Codex non-zero exit', { status: result.status, stderr: result.stderr?.substring(0, 500) });
      return null;
    }

    const output = result.stdout.trim();
    debug('Codex raw output:', output);

    const lines = output.split('\n');
    let agentMessage = null;

    for (const line of lines) {
      try {
        const event = JSON.parse(line);
        if (event.type === 'item.completed' && event.item?.type === 'agent_message') {
          agentMessage = event.item.text;
        }
      } catch {}
    }

    if (!agentMessage) {
      debug('No agent message found in Codex output');
      return null;
    }

    debug('Codex agent message:', agentMessage);

    const jsonMatch = agentMessage.match(/\{[\s\S]*"decision"[\s\S]*\}/);
    if (jsonMatch) return JSON.parse(jsonMatch[0]);
    return JSON.parse(agentMessage);
  } catch (err) {
    debug('Codex call failed:', err.message);
    return null;
  }
}

// ============================================================================
// Output
// ============================================================================

/**
 * Output the decision with optional status message
 * @param {string} decision - 'allow', 'deny', or 'ask'
 * @param {string} reason - Reason for the decision
 * @param {string} hookEventName - The hook event name
 * @param {object} options - Optional settings
 * @param {boolean} options.showMessage - Whether to show a system message (default: true for allow)
 * @param {string} options.source - Source of the decision for the message
 */
function outputDecision(decision, reason, hookEventName, options = {}) {
  const { showMessage = true, source = '' } = options;

  const output = {
    hookSpecificOutput: {
      hookEventName,
      permissionDecision: decision,
      permissionDecisionReason: reason,
    }
  };

  // Add a system message for visibility
  if (showMessage) {
    const sourceInfo = source ? ` [${source}]` : '';
    if (decision === 'allow') {
      output.systemMessage = `[Supervisor] Auto-approved${sourceInfo}: ${reason}`;
    } else if (decision === 'ask') {
      output.systemMessage = `[Supervisor] Asking${sourceInfo}: ${reason}`;
    } else if (decision === 'deny') {
      output.systemMessage = `[Supervisor] Blocked${sourceInfo}: ${reason}`;
    }
  }

  console.log(JSON.stringify(output));
}

// ============================================================================
// Stdin Reader
// ============================================================================

async function readStdin() {
  return new Promise((resolve) => {
    let data = '';
    process.stdin.setEncoding('utf8');
    process.stdin.on('readable', () => {
      let chunk;
      while ((chunk = process.stdin.read()) !== null) data += chunk;
    });
    process.stdin.on('end', () => resolve(data));
    setTimeout(() => resolve(data), 100);
  });
}

// ============================================================================
// Main Entry Point
// ============================================================================

async function main() {
  const hookType = process.argv[2];

  if (!hookType) {
    console.error('Usage: claude-supervisor <pre-tool-use|permission-request|post-tool-use>');
    process.exit(1);
  }

  // If disabled, return nothing - Claude uses its default behavior
  if (DISABLED) {
    debug('Supervisor disabled via CLAUDE_SUPERVISOR_DISABLED');
    return;
  }

  let input = null;

  try {
    const stdinData = await readStdin();

    if (!stdinData.trim()) {
      debug('No input received, falling back to ask');
      log('WARN', 'No input received', { hookType });
      outputDecision('ask', 'No input data received', hookType === 'pre-tool-use' ? 'PreToolUse' : 'PermissionRequest');
      return;
    }

    input = JSON.parse(stdinData);
    debug('Input:', JSON.stringify(input, null, 2));
    logRequest(hookType, input);

    const hookEventName = input.hook_event_name || (hookType === 'pre-tool-use' ? 'PreToolUse' : 'PermissionRequest');
    const sessionId = input.session_id;

    // Handle user-prompt-submit: Store the user's prompt for context
    if (hookType === 'user-prompt-submit') {
      const userPrompt = input.prompt || input.message || '';
      if (userPrompt) {
        recordUserPrompt(sessionId, userPrompt);
        log('INFO', 'User prompt recorded', { sessionId, promptLength: userPrompt.length });
      }
      // Return nothing to let the prompt proceed
      return;
    }

    // Handle post-tool-use: Record the action as allowed for session learning
    if (hookType === 'post-tool-use') {
      recordAllowedAction(sessionId, input);
      debug('Recorded successful tool use for session learning');

      // Patterns learned silently (no system message)
      return;
    }

    // Handle permission-request: User is already being prompted, just pass through
    // This avoids re-evaluating and potentially confusing Claude Code
    if (hookType === 'permission-request') {
      debug('Permission request - passing through to user prompt');
      log('INFO', 'Permission request passthrough', { toolName: input.tool_name });
      // Return nothing (no output) to let the default behavior proceed
      return;
    }

    // Check auto-accept env var first (full bypass)
    if (isAutoAcceptEnabled()) {
      debug('Auto-accept enabled via env var');
      log('INFO', 'Auto-accept enabled', { mode: 'env-var' });
      logDecision('allow', 'Auto-accept enabled via CLAUDE_SUPERVISOR_AUTO_ACCEPT', 'auto-accept', input);
      outputDecision('allow', 'Auto-accept enabled', hookEventName, { source: 'env' });
      return;
    }

    // Check session state for learned patterns
    const sessionCheck = checkSessionAllowed(sessionId, input);
    if (sessionCheck.allowed) {
      debug('Allowed by session learning:', sessionCheck.pattern);
      log('INFO', 'Allowed by session learning', { pattern: sessionCheck.pattern });
      logDecision('allow', `Previously allowed pattern: ${sessionCheck.pattern}`, 'session-learned', input);
      outputDecision('allow', sessionCheck.pattern, hookEventName, { source: 'learned' });
      return;
    }

    // If learned-only mode, and not learned, fall back to ask
    if (isLearnedAutoAcceptEnabled()) {
      debug('Learned-only mode, pattern not found, asking user');
      logDecision('ask', 'Pattern not learned yet', 'learned-mode', input);
      outputDecision('ask', 'Pattern not learned yet - approve to remember', hookEventName, { showMessage: false });
      return;
    }

    // Try fast-path rules
    const fastPathResult = checkFastPathRules(input);
    if (fastPathResult) {
      debug('Fast-path decision:', fastPathResult);
      logDecision(fastPathResult.decision, fastPathResult.reason, 'fast-path', input);
      outputDecision(fastPathResult.decision, fastPathResult.reason, hookEventName, {
        source: 'rules',
        showMessage: !fastPathResult.silent
      });
      return;
    }

    // No fast-path match - use Codex
    debug('No fast-path match, consulting Codex...');
    log('INFO', 'Consulting Codex LLM', { toolName: input.tool_name });
    const prompt = buildCodexPrompt(input, sessionId);
    const codexResult = callCodex(prompt);

    if (codexResult && codexResult.decision) {
      debug('Codex decision:', codexResult);
      // Codex should advise, not block - convert "deny" to "ask" so user decides
      const decision = codexResult.decision === 'deny' ? 'ask' : codexResult.decision;
      const reason = codexResult.reason || 'LLM decision';
      logDecision(decision, reason, 'codex', input);
      outputDecision(decision, reason, hookEventName, { source: 'LLM' });
      return;
    }

    // Fallback to asking user
    debug('Codex unavailable or invalid response, falling back to ask');
    log('WARN', 'Codex unavailable, falling back to ask', { toolName: input?.tool_name });
    logDecision('ask', 'Unable to determine automatically, please decide', 'fallback', input);
    outputDecision('ask', 'Unable to determine automatically, please decide', hookEventName, { showMessage: false });

  } catch (err) {
    debug('Error:', err.message);
    logError('Supervisor error', err, { hookType, toolName: input?.tool_name });
    outputDecision('ask', `Supervisor error: ${err.message}`, 'PreToolUse');
  }
}

main();
